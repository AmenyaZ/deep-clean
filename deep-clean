#!/usr/bin/env kscript

@file:DependsOn("com.offbytwo:docopt:0.6.0.20150202")

import org.docopt.Docopt
import java.io.File
import java.nio.file.Paths

val usage = """
This script nukes all build caches from Gradle/Android projects.
Run this in a Gradle/Android project folder.

Usage: deep-clean [options]

Options:
 --verbose -v  Print detailed information about all commands
 --dry-run -d  Don't delete anything. Useful for testing. Implies --verbose.

 ‚ö†Ô∏è THIS IS DANGEROUS SHIT ‚ö†Ô∏è
 --nuke    -n  Super-deep clean, includes Android build cache, global
               Gradle cache, etc. Nukes the entire thing from orbit ‚Äî
               it's the only way to be sure.
"""
val userHome = File(System.getProperty("user.home"))

val parsedArgs: Map<String, Any> = Docopt(usage).parse(args.toList())

val nukeItFromOrbit: Boolean = parsedArgs["--nuke"] as Boolean
val dryRun: Boolean = parsedArgs["--dry-run"] as Boolean
val wetRun = dryRun.not()
val verbose: Boolean = dryRun or parsedArgs["--verbose"] as Boolean
val gradlew = "./gradlew" + if (isOsWindows()) ".bat" else ""

Runtime.getRuntime().apply {
    println("‚è≥ Executing Gradle clean...")
    execOnWetRun("$gradlew clean -q")
        .printOutput(onlyErrors = false)

    println("üî´ Killing Gradle daemons...")
    execOnWetRun("$gradlew --stop")
        .printOutput()

    println("üî´ Killing ADB server...")
    execOnWetRun("adb kill-server")
        .printOutput() // TODO: proper output
    execOnWetRun("killall adb")

    val currentDir = File(Paths.get("").toAbsolutePath().toString())

    println("üî• Removing every 'build' folder...")
    currentDir.deleteSubfoldersMatching { it.name.toLowerCase() == "build" }

    println("üî• Removing every '.gradle' folder...")
    currentDir.deleteSubfoldersMatching { it.name.toLowerCase() == ".gradle" }

    if (nukeItFromOrbit) nukeGlobalCaches()

    println("üî´ Killing Kotlin compile daemon...\n  Note: this kills any CLI Java instance running")
    execOnWetRun("killall java")
}

fun Runtime.execOnWetRun(command: String) = exec(command)

fun Process.printOutput(onlyErrors: Boolean = true) {
    if (onlyErrors.not()) {
        inputStream.bufferedReader().lines().forEach { println(it) }
    }
    errorStream.bufferedReader().lines().forEach { println(it) }
}

fun File.deleteSubfoldersMatching(matcher: (file: File) -> Boolean) {
    this.listFiles { file -> file.isDirectory }
        .filter(matcher)
        .onEach { if (verbose) println("\tDeleting directory: ${it.absolutePath}") }
        .forEach { if (wetRun) it.deleteRecursively() }
}

fun Runtime.nukeGlobalCaches() {
    println()
    println("‚ò¢Ô∏è ‚ò¢ Ô∏è‚ò¢Ô∏è  WARNING: nuke mode activated ‚ò¢ Ô∏è‚ò¢ Ô∏è‚ò¢Ô∏è")
    println("This will affect system-wide caches for Gradle and IDEs!")
    println("‚ö†Ô∏è  You will lose local version history and other IDE data!")
    println()

    println("‚è≥ Clearing Android Gradle build cache...")
    exec("$gradlew cleanBuildCache")

    println("üî• Clearing ${Ide.IntelliJIdea} caches...")
    clearIdeCache(Ide.IntelliJIdea)

    println("üî• Clearing ${Ide.AndroidStudio} caches...")
    clearIdeCache(Ide.AndroidStudio)

    println("üî• Clearing Gradle home directory...")
    userHome.deleteSubfoldersMatching { it.name.toLowerCase() == ".gradle" }
}

fun clearIdeCache(ide: Ide) {
    locateCacheFolderFor(ide)
        .onEach {
            println("\tClearing cache for $ide ${it.parentFile.name.substringAfter(ide.folderPrefix)}...")
            if (verbose) println("\t  Deleting directory: ${it.absolutePath}")
        }
        .forEach { if (wetRun) it.deleteRecursively() }
}

sealed class Ide(private val name: String, val folderPrefix: String) {
    object IntelliJIdea : Ide("IntelliJ IDEA", "IntelliJIdea")
    object AndroidStudio : Ide("Android Studio", "AndroidStudio")

    override fun toString() = name
}

fun locateCacheFolderFor(ide: Ide): List<File> {
    return when {
        isOsWindows() || isOsLinux() -> {
            userHome.listFiles { file -> file.isDirectory }
                .filter { it.name.startsWith(".${ide.folderPrefix}") }
                .map { File(it, "system") }
        }
        isOsMacOs() -> {
            File(userHome, "Library/Caches")
                .listFiles { file -> file.isDirectory }
                .filter { it.name.startsWith(ide.folderPrefix, ignoreCase = true) }
                .map { File(it, "system") }
        }
        else -> {
            println("\tUnsupported OS, skipping.")
            emptyList()
        }
    }
}

fun isOsWindows() = System.getProperty("os.name").startsWith("Windows", ignoreCase = true)
fun isOsLinux() = System.getProperty("os.name").startsWith("Linux", ignoreCase = true)
fun isOsMacOs() = System.getProperty("os.name").startsWith("Mac", ignoreCase = true)
